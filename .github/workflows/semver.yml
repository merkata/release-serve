name: Semantic Versioning

on:
  workflow_call:
    inputs:
      version_strategy:
        description: 'The versioning strategy to use (auto, major, minor, patch)'
        required: false
        default: 'auto'
        type: string
      prerelease:
        description: 'Custom prerelease identifier'
        required: false
        default: ''
        type: string
      project_type:
        description: 'Project type (maven, node)'
        required: true
        type: string
    outputs:
      new_version:
        description: 'The calculated new version'
        value: ${{ jobs.calculate_version.outputs.new_version }}
      version_changed:
        description: 'Whether the version was changed'
        value: ${{ jobs.calculate_version.outputs.version_changed }}
      is_prerelease:
        description: 'Whether the version is a prerelease'
        value: ${{ jobs.calculate_version.outputs.is_prerelease }}
      version_category:
        description: 'The category of the version (dev, rc, release)'
        value: ${{ jobs.calculate_version.outputs.version_category }}

jobs:
  calculate_version:
    name: Calculate Semantic Version
    runs-on: ubuntu-latest
    outputs:
      new_version: ${{ steps.semver.outputs.new_version }}
      version_changed: ${{ steps.semver.outputs.version_changed }}
      is_prerelease: ${{ steps.semver.outputs.is_prerelease }}
      version_category: ${{ steps.semver.outputs.version_category }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0  # Need full history for proper versioning
      
      - name: Set up Java
        if: ${{ inputs.project_type == 'maven' }}
        uses: actions/setup-java@v3
        with:
          distribution: 'temurin'
          java-version: '17'
      
      - name: Set up Node.js
        if: ${{ inputs.project_type == 'node' }}
        uses: actions/setup-node@v3
        with:
          node-version: '16'
      
      - name: Get Current Version (Maven)
        if: ${{ inputs.project_type == 'maven' }}
        id: maven_version
        run: |
          CURRENT_VERSION=$(mvn help:evaluate -Dexpression=project.version -q -DforceStdout)
          echo "current_version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
      
      - name: Get Current Version (Node)
        if: ${{ inputs.project_type == 'node' }}
        id: node_version
        run: |
          CURRENT_VERSION=$(node -p "require('./package.json').version")
          echo "current_version=$CURRENT_VERSION" >> $GITHUB_OUTPUT

      - name: Setup Node.js for semantic-release
        uses: actions/setup-node@v3
        with:
          node-version: '20'
          
      - name: Install semantic-release
        run: |
          npm install -g semantic-release @semantic-release/git @semantic-release/changelog @semantic-release/exec conventional-changelog-conventionalcommits

      - name: Create semantic-release config
        run: |
          cat > .releaserc.json << 'EOF'
          {
            "branches": [
              "+([0-9])?(.{+([0-9]),x}).x",
              "main",
              "master",
              {"name": "develop", "prerelease": "dev"},
              {"name": "release/*", "prerelease": "rc"},
              {"name": "feature/*", "prerelease": "alpha"}
            ],
            "plugins": [
              ["@semantic-release/commit-analyzer", {
                "preset": "conventionalcommits",
                "releaseRules": [
                  {"type": "feat", "release": "minor"},
                  {"type": "fix", "release": "patch"},
                  {"type": "docs", "release": "patch"},
                  {"type": "style", "release": "patch"},
                  {"type": "refactor", "release": "patch"},
                  {"type": "perf", "release": "patch"},
                  {"type": "test", "release": "patch"},
                  {"type": "build", "release": "patch"},
                  {"type": "ci", "release": "patch"},
                  {"type": "chore", "release": "patch"},
                  {"scope": "deps", "release": "patch"}
                ]
              }],
              "@semantic-release/release-notes-generator",
              ["@semantic-release/exec", {
                "verifyConditionsCmd": "echo 'Verify conditions'",
                "analyzeCommitsCmd": "echo '${nextRelease.version'",
                "prepareCmd": "echo 'NEXT_VERSION=${nextRelease.version}' >> $GITHUB_ENV"
              }]
            ]
          }
          EOF
      
      - name: Run semantic-release analysis
        id: semantic_release
        env:
          GITHUB_TOKEN: ${{ github.token }}
          VERSION_STRATEGY: ${{ inputs.version_strategy }}
          PRERELEASE: ${{ inputs.prerelease }}
          CURRENT_VERSION: ${{ steps.maven_version.outputs.current_version || steps.node_version.outputs.current_version }}
        run: |
          # Run semantic-release in dry-run mode to analyze which release type would be performed
          npx semantic-release --dry-run

          # Get the current version components
          IFS='.' read -r -a VERSION_PARTS <<< "$CURRENT_VERSION"
          MAJOR="${VERSION_PARTS[0]}"
          MINOR="${VERSION_PARTS[1]}"
          PATCH="${VERSION_PARTS[2]%%[-+]*}"  # Remove any pre-release or build metadata

          # If semantic-release determined a new version, use it, otherwise respect manual override
          if [[ -n "$NEXT_VERSION" ]]; then
            echo "semantic-release determined version: $NEXT_VERSION"
            NEXT_RELEASE_TYPE="auto"
            
            # If the next version from semantic-release has major change
            if [[ "$NEXT_VERSION" == $(($MAJOR+1))\.* ]]; then
              NEXT_RELEASE_TYPE="major"
            # If the next version from semantic-release has minor change
            elif [[ "$NEXT_VERSION" == $MAJOR\.$(($MINOR+1))\.* ]]; then
              NEXT_RELEASE_TYPE="minor"
            # If the next version from semantic-release has patch change
            elif [[ "$NEXT_VERSION" == $MAJOR\.$MINOR\.$(($PATCH+1)) ]]; then
              NEXT_RELEASE_TYPE="patch"
            fi
          fi
          
          # Manual version strategy takes precedence if specified
          if [[ "$VERSION_STRATEGY" != "auto" ]]; then
            echo "Manual version strategy detected: $VERSION_STRATEGY"
            if [[ "$VERSION_STRATEGY" == "major" ]]; then
              MAJOR=$((MAJOR + 1))
              MINOR=0
              PATCH=0
            elif [[ "$VERSION_STRATEGY" == "minor" ]]; then
              MINOR=$((MINOR + 1))
              PATCH=0
            elif [[ "$VERSION_STRATEGY" == "patch" ]]; then
              PATCH=$((PATCH + 1))
            fi
            NEW_VERSION="${MAJOR}.${MINOR}.${PATCH}"
          else
            # Use semantic-release suggested version if available
            if [[ -n "$NEXT_VERSION" ]]; then
              NEW_VERSION="$NEXT_VERSION"
            else
              # Fallback to patch increment if semantic-release doesn't suggest a version
              NEW_VERSION="${MAJOR}.${MINOR}.$(($PATCH + 1))"
            fi
          fi
          
          # Determine branch type for prerelease identifier
          BRANCH_NAME=${GITHUB_REF#refs/heads/}
          
          # Add pre-release identifier
          IS_PRERELEASE="false"
          VERSION_CATEGORY="release"
          
          if [[ -n "$PRERELEASE" ]]; then
            # Custom prerelease identifier takes precedence
            NEW_VERSION="${NEW_VERSION}-${PRERELEASE}.${GITHUB_RUN_NUMBER}"
            IS_PRERELEASE="true"
            VERSION_CATEGORY="${PRERELEASE}"
          elif [[ "$BRANCH_NAME" == "develop" ]]; then
            NEW_VERSION="${NEW_VERSION}-dev.${GITHUB_RUN_NUMBER}"
            IS_PRERELEASE="true"
            VERSION_CATEGORY="dev"
          elif [[ "$BRANCH_NAME" == release/* ]]; then
            NEW_VERSION="${NEW_VERSION}-rc.${GITHUB_RUN_NUMBER}"
            IS_PRERELEASE="true"
            VERSION_CATEGORY="rc"
          elif [[ "$BRANCH_NAME" != "main" && "$BRANCH_NAME" != "master" ]]; then
            NEW_VERSION="${NEW_VERSION}-alpha.${GITHUB_RUN_NUMBER}"
            IS_PRERELEASE="true"
            VERSION_CATEGORY="alpha"
          fi
          
          # Add build metadata
          NEW_VERSION="${NEW_VERSION}+${GITHUB_SHA::8}"
          
          echo "Calculated final version: $NEW_VERSION"
          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "is_prerelease=$IS_PRERELEASE" >> $GITHUB_OUTPUT
          echo "version_category=$VERSION_CATEGORY" >> $GITHUB_OUTPUT
          
          if [[ "$CURRENT_VERSION" != "$NEW_VERSION" ]]; then
            echo "version_changed=true" >> $GITHUB_OUTPUT
          else
            echo "version_changed=false" >> $GITHUB_OUTPUT
          fi
      
      - name: Update Version (Maven)
        if: ${{ inputs.project_type == 'maven' && steps.semver.outputs.version_changed == 'true' }}
        run: |
          mvn versions:set -DnewVersion=${{ steps.semver.outputs.new_version }} -DgenerateBackupPoms=false
      
      - name: Update Version (Node)
        if: ${{ inputs.project_type == 'node' && steps.semver.outputs.version_changed == 'true' }}
        run: |
          npm version ${{ steps.semver.outputs.new_version }} --no-git-tag-version
      
      - name: Create Git Tag
        if: ${{ steps.semver.outputs.version_changed == 'true' }}
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git tag -a v${{ steps.semver.outputs.new_version }} -m "Release v${{ steps.semver.outputs.new_version }}"
          
          # Don't push tag on non-main branches to avoid conflicts
          if [[ "${GITHUB_REF#refs/heads/}" == "main" || "${GITHUB_REF#refs/heads/}" == "master" ]]; then
            git push origin v${{ steps.semver.outputs.new_version }}
          fi
